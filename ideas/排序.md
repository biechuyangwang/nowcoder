# 排序
## 1 自定义排序规则
### 1.1 使用函数对象自定义排序规则
```cpp
# include<bits/stdc++.h>
using namespace std;

class cmp{
public:
    bool operator()(const string &a, const string &b){
        return (a.length() < b.length());
    }
}

int main(){
    set<string, cmp>myset = {"lijun","xingqiliudegushi","biechuyangwang"};
    for(auto i : myset) cout << i << endl;
    return 0;
}

// output: 
/*
lijun
biechuyangwang
xingqiliudegushi
*/
```
### 1.2 map使用函数对象自定义排序规则
```cpp
class cmp{
public:
    bool operator()(const string &a, const string &b){
        return a.length() < b.length();
    }
};

int main(){
	map<string, int, cmp>mp={{"lijun",5}, {"xingqiliudegushi", 16}, {"biechuyangwang", 14}};  // 只能按照关键字排序
	for(auto &i : mp) cout << i.first <<" " << i.second << endl;
	return 0;
}
```
如果需要**按照value排序**或者组合排序，需要放到vector中再进行排序。
```cpp
#include<bits/stdc++.h>
using namespace std;

class cmp{
public:
    bool operator()(pair<string, int>const &a, pair<string, int>const &b){
        if(a.second != b.second)
            return a.second > b.second;
        else return a.first <= b.first;
    }
};

int main(){
	map<string, int>mp={{"lijun",5}, {"xingqiliudegushi", 16}, {"biechuyangwang", 16}};
	vector<pair<string, int>>vec(mp.begin(), mp.end());  // 放入vector
	sort(vec.begin(), vec.end(), cmp());  // 然后用函数对象进行排序。记得cmp要加括号
	for(auto &i : vec) cout << i.first <<" " << i.second << endl;
	return 0;
}
```

### 1.3 优先队列(堆)
```cpp
class cmp{
public:
    bool operator()(int& x, int& y){
        return x < y;  // 默认的less方式，也就是大顶堆
        // return x > y;  // greater，小顶堆
    }
};

//  第一个参数是元素类型，第二个参数是基础容器，第三个参数是函数对象（仿函数）用于排序断言。
priority_queue<int, vector<int>, cmp> pq;  
```
